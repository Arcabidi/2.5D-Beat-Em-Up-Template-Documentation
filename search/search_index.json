{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Summary</p> <p>Welcome to the documentation site for the 2.5D Beat 'Em Up Template developed by Arcabidi! This page will get you started on everything you need to know to use this package.</p> <p>Want to make a 2.5D beat 'em up game but don't know where to start? This template provides a starting point for beginner and intermediate developers to build their very own belt-scrolling brawler.</p> <p>This package combines 2D visuals with 3D depth to add a modern feel to the classic beat 'em up experience. Its modular design allows for extensive customization (units, abilities, AI, etc.), and it can easily be adapted to support various 2.5D genres beyond beat 'em ups such as platformers or adventure games.</p> An example of prototype to product"},{"location":"#section-guide","title":"Section guide","text":"<ul> <li>Releasessee what new features are included in the latest version</li> <li>Unity Editorunderstand how the project is organized in the Unity Editor</li> <li>Assetslearn how to dynamically load and unload items at runtime</li> <li>Scenestake control of how your game transitions between its sections</li> <li>Systemsdeep dive into the systems that power the template</li> </ul>"},{"location":"#package-dependencies","title":"Package dependencies","text":"<p>Info</p> <p>This template only uses official packages made by Unity.</p> <ul> <li>Addressables (For asset management)</li> <li>Input System (For player input)</li> <li>Universal Render Pipeline (For rendering)</li> </ul>"},{"location":"#downloads","title":"Downloads","text":"<p>Unity Store</p>"},{"location":"assets/","title":"Assets","text":"<p>Summary</p> <p>This page explains how items are dynamically loaded and unloaded using Unity's Addressables package.</p>"},{"location":"assets/#design-decisions","title":"Design decisions","text":"<p>This template makes the following design decisions regarding the default way Unity handles assets:</p>"},{"location":"assets/#asset-system","title":"Asset system","text":"<p>Unity\u2019s default Asset system is the Resource system. Developers store assets in one or more folders named Resources and load or unload Objects from those assets at runtime.</p> <p>Danger</p> <p>The Resource system is very limited and prone to bloating. Unity themselves do not recommend using the Resource system for projects past the prototyping phase.</p> <p>An alternative to the Resource system is to use AssetBundles. An AssetBundle is an archive file that contains platform-specific non-code content (models, textures, prefabs, audio, etc.) that Unity can load at runtime. AssetBundles are commonly used to update or add content post-release such as DLC, limited-time promotional events, or holiday themes. They can reduce initial file size, optimize asset loading based on user platform, reduce memory runtime pressure, and even allow content to be reused from project to project.</p> <p>In 2019 Unity released a new quality-of\u2013life way to manage AssetBundles. This template will use that new asset system.</p>"},{"location":"assets/#addressables-package","title":"Addressables package","text":""},{"location":"assets/#1-installation","title":"1. Installation","text":"<p>The Addressables package is not enabled by default and must be installed using the Package Manager at  <code>Window &gt; Package Manager</code>. </p>"},{"location":"assets/#2-mark-addressable-assets","title":"2. Mark Addressable assets","text":"<p>Once it is installed the second step is to mark all Addressable content in the project. Any content marked this way can be dynamically loaded or unloaded at runtime.  This is done by selecting an asset in the Project window and checking the now available Addressable box in the Inspector. In the example below the Persistent scene has been marked as an Addressable asset. You can find it at <code>BeatEmUpTemplate/Assets/WorkingInUnity/Scenes</code>. </p>"},{"location":"assets/#3-form-addressables-groups","title":"3. Form Addressables groups","text":"<p>The third step is to organize Addressable content into groups. You can view a list of all Addressables in the project at <code>Window &gt; Asset Management &gt; Addressables &gt; Groups</code>. Here you can see all of the Addressables groups in the template and the assets under each group. </p> <p> When you mark an asset as Addressable it is placed in the Default Local Group by default, but you can create your own custom groups and move assets into them or set a new default folder if you wish.</p>"},{"location":"assets/#4-choose-bundlemodes","title":"4. Choose BundleModes","text":"<p>The fourth step is to adjust the way each Addressables group is packed into AssetBundles by changing its BundleMode. These settings can be found at <code>Assets/AddressableAssetsData/AssetGroups/[Addressable Group Name].asset</code> where each Addressables group has its own settings file. </p> <p> Based on the BundleMode chosen, the assets in an Addressable group will either be Packed Together into a single bundle, Packed Separately into their own individual bundles, or Packed Together By Label into a bundle with all other assets that share the same label (regardless of Addressable group). The exceptions are Scene assets, which are always packed separately.</p>"},{"location":"assets/#5-convert-to-assetbundles","title":"5. Convert to AssetBundles","text":"<p>The final step is to convert the assets in your Addressables groups into AssetBundles. Whenever Addressable assets are modified during development, the project\u2019s Addressables content must be rebuilt before building the Player. This can be done in one of two ways. The first is manually through the Build Menu of the groups window. </p> <p> The second is automatically as part of the Player build. This can be configured in the project\u2019s Addressable Asset Settings file located at <code>Assets/AddressableAssetsData/AddressableAssetSettings.asset</code>.  </p> <p> While running the Addressables content build at the same time as the Player build may be convenient, it could increase build time on larger projects, especially if no assets have been modified since the last build.</p>"},{"location":"assets/#6-build-reports","title":"6. Build reports","text":"<p>To view the AssetBundles that were created, you must enable Build Reports at <code>Edit &gt; Preferences &gt; Addressables &gt; Debug Build Layout</code>. </p> <p> You can set the report to open after every build, or view the reports manually at <code>Window &gt; Asset Management &gt; Addressables &gt; Addressables Report</code>. </p> <p> The report will also notify you of any potential risks for asset duplication, where a single non-Addressable asset is referenced by multiple AssetBundles. If this happens, you may want to mark the risky asset as Addressable and assign it to an appropriate group.</p>"},{"location":"assets/#7-profiler-module","title":"7. Profiler module","text":"<p>Once BuildReports are enabled the Addressables Profiler module can notify you at runtime whenever AssetBundles are loaded or unloaded. You can use this information to optimize the memory usage of your game. The first step is to install the Unity Profiling Core API. It may have been included automatically when you installed the Addressables package, but if it wasn't you can search for it in the PackageManager. </p> <p> Next, open the Profiler window at <code>Window &gt; Analysis &gt; Profile</code> and enable Addressable Assets from the Profiler Modules drop down menu so that they can be monitored. </p> <p> Lastly, the Profiler module only supports the Use Existing Build setting for the Play Mode Script. Make sure your Addressables build exists, then select the appropriate option from the Play Mode Script menu of the groups window. </p> <p> Now when you enter Play Mode, the module view can display whatever Addressables content is loaded at any given point in time. </p>"},{"location":"assets/#addressableassetsdata-folder","title":"AddressableAssetsData folder","text":"<p>The non-code files in this section are at <code>Assets/AddressableAssetsData</code>.</p> <p>This folder is automatically created when you install the Addressables package from the Unity Package Manager. It contains all the settings files for managing Addressables, which help you organize and package content for your application as well as load and release assets at runtime.</p>"},{"location":"releases/","title":"Releases","text":"<p>Summary</p> <p>This page archives the changelog for every version of the template.</p>"},{"location":"releases/#v100","title":"v1.0.0","text":"<ul> <li>Initial release</li> </ul>"},{"location":"scenes/","title":"Scenes","text":"<p>Summary</p> <p>This page explains how scenes are loaded, unloaded, and transition between each other.</p>"},{"location":"scenes/#flowchart","title":"Flowchart","text":"<pre><code>flowchart LR\n  subgraph Addressable scenes\n    direction TB\n    subgraph Always Loaded\n        direction TB\n        Persistent\n    end\n    subgraph Loaded/Unloaded\n        direction LR\n        Boot --&gt; Title\n        Title --&gt; Training\n        Training --&gt; |Lose| Boot\n        Training --&gt; |Win| Title\n    end\n  end\nInitialization --&gt; Persistent\nPersistent --&gt; Loaded/Unloaded</code></pre> <p>All scene files are located at <code>BeatEmUpTemplate/Assets/WorkingInUnity/Scenes</code>.</p>  Scene Name Description <code>Initialization</code> The only non-Addressable scene in the project and the initial scene in the final build. It is near empty by design to minimize build size since all other scenes can be loaded dynamically as needed. All this scene does is load the Persistent scene before unloading itself. <code>Persistent</code> This scene persists throughout the lifetime of the game and does not unload until the application exits. It contains all essential GameObjects and scripts that shouldn\u2019t be destroyed between scenes such as the SceneLoader and Cursor.It allows these core game systems to initialize completely before additively loading one of the following scenes (by default this is the Boot scene, but it can load into any other scene directly for development purposes). <code>Boot</code> The first scene that has any visual elements. It plays the game\u2019s opening credits while asynchronously loading the Title scene in the background. Once it is 90% loaded the player can either skip the rest of the credits or wait until they finish, after which the Title scene will fully load and the Boot scene will unload. <code>Title</code> The scene that contains the game\u2019s title along with the main menu. The player can choose to Start The Game after which the Training Scene will load and the Title scene will unload. <code>Training</code> The scene that contains the core gameplay loop. It is presented in 2.5D, where graphics are in 3D but gameplay is in 2D. The player fights until all enemies are defeated or they are.If the player is defeated they will have until a countdown timer expires to attempt to continue. If they fail to continue the Boot scene will load and the Training scene will unload. If they successfully continue the Training scene will reload instead.If the enemy is defeated the Title scene will load and the Training scene will unload."},{"location":"unity-editor/","title":"Unity Editor","text":"<p>Summary</p> <p>This page describes how the Unity environment is organized for the template. It can help you navigate through the project\u2019s files or bring up details you may want to consider when organizing your own game.</p>"},{"location":"unity-editor/#automatic-setup","title":"Automatic setup","text":"<p>This package includes automatic setup features to ensure a smooth experience when importing into a Unity project. These scripts are located at <code>BeatEmUpTemplate/Assets/Scripting/Editor</code>.</p> <p>Once the import is detected <code>AutoSetupManager.cs</code> runs all setup tasks in sequence:</p> <ol> <li>Configures the Input System (<code>InputSystemSetup.cs</code>)</li> <li>Sets up URP assets (<code>URPAutoSetup.cs</code>)</li> <li>Opens the Initialization scene (<code>InitializationSceneOpener.cs</code>)</li> <li>Shows the Welcome screen (<code>WelcomeScreen.cs</code>)</li> </ol> <p>You can also manually run the setup by selecting <code>Window &gt; Arcabidi &gt; 2.5D Beat 'Em Up Template &gt; Run Auto Setup</code>. See <code>AutoSetupGuide.txt</code> for more information.</p>"},{"location":"unity-editor/#project-window","title":"Project window","text":"<p>The Project window is located in the bottom left corner of the Unity Editor by default. The following is a general description of each major folder contained within.</p>  Folder Name Description <code>AddressableAssetsData</code> A folder that is automatically created when you install the Addressables package from the Unity Package Manager.This folder contains all the settings files for managing Addressables, which help you organize and package content for your application as well as load and release assets at runtime.See the Assets page for more information. <code>Arcabidi</code> The company folder for all products created by Arcabidi. <code>BeatEmUpTemplate</code> The main folder for all files related to the 2.5D Beat 'Em Up Template. <code>Assets</code> Contains all assets related to the 2.5D Beat 'Em Up Template. Its subfolders are named after sections from the online Unity 6 User Manual to allow quick references to official documentation. <code>Animation</code> Contains all non-code files related to animation. See the Animation page for more information. <code>Audio</code> Contains all non-code files related to audio. See the Audio page for more information. <code>MaterialsAndShaders</code> Contains all non-code files related to how surfaces are rendered. See the Materials and Textures pages in the Unity 6 User Manual for more information. <code>Rendering</code> Contains all non-code files related to how scene content is displayed on screen. See the Universal Render Pipeline asset page in the Unity 6 User Manual for more information. <code>Scripting</code> Contains all code files. See the Systems page for more information. <code>Video</code> Contains all non-code files related to video. See the Video Clip Importer page in the Unity 6 User Manual for more information. <code>WorkingInUnity</code> Contains all non-code files related to working in Unity. <code>GameObjects</code> Contains all non-code files related to GameObjects. See the Models and Prefabs pages in the Unity 6 User Manual for more information. <code>Input</code> Contains all non-code files related to input. See the Input page for more information. <code>Scenes</code> Contains all non-code files related to scenes. See the Scenes page for more information. <code>UI</code> Contains all non-code files related to UI. See the UI page for more information. <code>Licenses</code> Contains all licenses associated with any third party assets used in the package. <code>Third-Party Notices.txt</code> details which asset uses which license."},{"location":"unity-editor/#hierarchy-window","title":"Hierarchy window","text":"<p>The Hierarchy window is located in the top left corner of the Unity Editor by default. For this template GameObjects in the hierarchy have been divided based on the system they belong to and sorted by their transforms rather than alphanumerically. For example, in the Training scene above the UIManager is placed under the UI system while the AudioManager is placed under the Audio system.</p> <p>Info</p> <p>Unity uses this same format for the hierarchy window in its own sample projects.  </p>"},{"location":"systems/","title":"Systems","text":"<p>Summary</p> <p>This page outlines the twelve core systems that make up the 2.5D Beat 'Em Up Template.</p>"},{"location":"systems/#overview","title":"Overview","text":"<p>Some systems are made entirely out of code files while others have both code and non-code elements. See each system's dedicated page for more information.</p> <ul> <li>Abilityeverything and anything units can do</li> <li>Actioncontrol what a unit knows how to do</li> <li>Animationbring objects in the scene to life</li> <li>Audioplay dynamic background music and sound effects</li> <li>Commanddetermine when in-game actions should be performed</li> <li>Environmentbuild immersive and responsive worlds</li> <li>Gamechange the game's state and direct its flow</li> <li>Hitboxtransfer data between two bodies through collision detection</li> <li>Inputswitch between different control schemes</li> <li>Playermanage both human and AI players</li> <li>UIdesign custom menus and transitions</li> <li>Unitcreate, customize and manage the lifetime of in-game units</li> <li>Utilitiesgeneral-purpose tools that can be used anywhere, in any game, when needed</li> </ul>"},{"location":"systems/#scripting-folder","title":"Scripting folder","text":"<p>All of the code files for each system are located at <code>BeatEmUpTemplate/Assets/Scripting</code>.</p> <p>Each folder is further divided by script type:</p>  Folder Name Description <code>CSharp</code> Contains scripts that are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked, or are abstract classes representing concepts like Players or Teams. <code>Enums</code> Contains groups of related constants that are meant to be used by other scripts. All classes in these folders use the <code>enum</code> keyword in their declaration. <code>Interfaces</code> Contain collections of method signatures and properties that can be implemented by other scripts. All classes in these folder use the <code>interface</code> keyword in their declaration.Interfaces act like a contract; when a class implements an interface, an instance of that class can also be treated as an instance of that interface. This functionality means that two unrelated classes can be treated in the same way through an interface that they both implement. <code>MonoBehaviours</code> Contain scripts that are meant to be attached to GameObjects in the scene as components. All classes in these folders inherit from Unity's MonoBehaviour class. Many of them represent managers, controllers, and responders specific to scenes or prefabs. <code>PropertyAttributes</code> Contains custom attributes for script variables. All classes in this folder derive from Unity's base PropertyAttribute class. <code>PropertyDrawers</code> Contains custom drawers to control how script variables with custom PropertyAttributes appear in the Inspector. All classes in this folder derive from Unity's base PropertyDrawer class. <code>ScriptableObjects</code> Contains centralized data that can be conveniently accessed from scenes and assets within a project. All classes in this folder derive from Unity's base ScriptableObject class.ScriptableObjects are stored on disk and live independently of GameObjects and class instances. They are used as data containers to save large amounts of data, reducing a project\u2019s memory usage by not duplicating values. <code>StateMachineBehaviours</code> Contains components that can be added to a state machine state. All classes in this folder derive from Unity's base StateMachineBehaviour class. See the Animation page for more information. <code>Structs</code> Contains user-defined data types that combine fields of different types underneath a single type. All classes in this folder use the <code>struct</code> keyword in their declaration. <code>VisualElements</code> Contains objects that are part of the UIElements visual tree. All classes in this folder derive from Unity's base VisualElement class. See the UI page for more information."},{"location":"systems/ability/","title":"Ability","text":"<p>Summary</p> <p>This page summarizes all aspects of the ability system, which includes everything and anything units can do.</p>"},{"location":"systems/ability/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Ability</code>.</p>"},{"location":"systems/ability/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/ability/#abilitydata","title":"AbilityData","text":"<pre><code>classDiagram\n    AbilityData &lt;|-- JabAbilityData\n    AbilityData &lt;|-- CrossAbilityData\n    class AbilityData{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>AbilityData represents all data transferred by a hitbox to targets on hit.</p> <p><code>AbilityData.cs</code> defines what is common across all AbilityData, regardless of game. There is currently nothing common across all AbilityData, so this abstract class only serves as an empty base class for its potential child classes.</p> <p><code>JabAbilityData.cs</code> defines the data that is transferred by the JabHitbox in the Jab ability. This includes things like damage and hitstun duration.</p> <p><code>CrossAbilityData.cs</code> defines the data that is transferred by the CrossHitbox in the Cross ability. This includes things like a knockback's direction, magnitude, and duration.</p>"},{"location":"systems/ability/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/ability/#abilities","title":"Abilities","text":"<pre><code>classDiagram\n    Ability &lt;|-- BeltScrollMove\n    Ability &lt;|-- Jump\n    Ability &lt;|-- Jab\n    Ability &lt;|-- Cross\n    class Ability{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>Abilities represent skills that can be performed by a user.</p> <p>Note</p> <p>Abilities are different from UnitActions. For example, a UnitAction named <code>FireBarrage</code> could have a unit cast three random fire spells in succession, each of which are their own separate ability.</p> <p><code>Ability.cs</code> defines what is common across all abilities regardless of game. This includes things like having a reference to the Command instance that created it and a way to execute the ability.</p> <p><code>BeltScrollMove.cs</code> executes belt scroll movement, where a unit performs 3D movement from a 2D perspective where the \"up\" input traverses depth instead of height. This component is attached to the Hero and Villain prefabs in the Training scene at runtime whenever they move.</p> <p><code>Jump.cs</code> executes a jump where a unit pushes upward from the ground to become airborne. This component is briefly attached to the Hero prefab in the Training scene at runtime whenever it jumps.</p> <p><code>Jab.cs</code> executes a jab where a unit throws a quick, sharp punch with their leading hand. This component is briefly attached to the Villain prefab in the Training scene at runtime whenever it attacks.</p> <p><code>Cross.cs</code> executes a cross where a unit throws a strong, straight punch with their rear hand. This component is briefly attached to the Hero prefab in the Training scene at runtime whenever it attacks.</p>"},{"location":"systems/ability/#abilitymanagers","title":"AbilityManagers","text":"<pre><code>classDiagram\n    class AbilityManager{\n    }</code></pre> <p>AbilityManagers manage abilities once they have been added to a user.</p> <p><code>AbilityManager.cs</code> represents a basic, general-purpose AbilityManager used by the template. It notifies UnitControllers and StateMachineBehaviours when abilities implementing relevant interfaces are added. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/ability/#structs","title":"Structs","text":"<p>These scripts contain user-defined data types that combine fields of different types underneath a single type. All classes in this folder use the <code>struct</code> keyword in their declaration.</p>"},{"location":"systems/ability/#abilitydatapacket","title":"AbilityDataPacket","text":"<pre><code>classDiagram\n    class AbilityDataPacket{\n    &lt;&lt;Struct&gt;&gt;\n    }</code></pre> <p><code>AbilityDataPacket.cs</code> contains the AbilityData sent from Hitboxes by an Ability. The AbilityData within can be modified by the ability, the Command instance that created the ability, the user of the ability, and the target of the ability. The AbilityDataPacket saves a version of the AbilityData at each step in case it is needed for reference.</p>"},{"location":"systems/action/","title":"Action","text":"<p>Summary</p> <p>This page summarizes all aspects of the action system, which is responsible for controlling what a unit knows how to do.</p>"},{"location":"systems/action/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Action</code>.</p>"},{"location":"systems/action/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/action/#unitactionmanagers","title":"UnitActionManagers","text":"<pre><code>classDiagram\n    class UnitActionManager{\n    }</code></pre> <p>UnitActionManagers manage the UnitActions a unit knows how to perform.</p> <p><code>UnitActionManager.cs</code> represents a basic, general-purpose UnitActionManager in the template. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/action/#scriptableobjects","title":"ScriptableObjects","text":"<p>These scripts contain centralized data that can be conveniently accessed from scenes and assets within a project. All classes in this folder derive from Unity's base ScriptableObject class.</p> <p>ScriptableObjects are stored on disk and live independently of GameObjects and class instances. They are used as data containers to save large amounts of data, reducing a project\u2019s memory usage by not duplicating values.</p>"},{"location":"systems/action/#unitactions","title":"UnitActions","text":"<pre><code>classDiagram\n    UnitAction &lt;|-- BeltScrollMoveUnitAction\n    UnitAction &lt;|-- JumpUnitAction\n    UnitAction &lt;|-- JabUnitAction\n    UnitAction &lt;|-- CrossUnitAction\n    class UnitAction{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>UnitActions represent actions that units can perform.</p> <p>Note</p> <p>UnitActions are different from abilties. For example, a UnitAction named <code>FireBarrage</code> could have a unit cast three random fire spells in succession, each of which are their own separate ability.</p> <p><code>UnitAction.cs</code> defines what is common across all UnitActions regardless of game. This includes things like returning an instanced version of itself called a Command.</p> <p><code>BeltScrollMoveUnitAction.cs</code> represents the knowledge of performing the BeltScrollMove ability. Both the Hero and Villain prefabs know this UnitAction in their UnitActionManager components.</p> <p><code>JumpUnitAction.cs</code> represents the knowledge of performing the Jump ability. The Hero prefab knows this UnitAction in its UnitActionManager component.</p> <p><code>JabUnitAction.cs</code> represents the knowledge of performing the Jab ability. The Villain prefab knows this UnitAction in its UnitActionManager component.</p> <p><code>CrossUnitAction.cs</code> represents the knowledge of performing the Cross ability. The Hero prefab knows this UnitAction in its UnitActionManager component.</p>"},{"location":"systems/animation/","title":"Animation","text":"<p>Summary</p> <p>This page summarizes all aspects of the animation system, which is responsible for bringing objects in the scene to life.</p>"},{"location":"systems/animation/#design-decisions","title":"Design decisions","text":"<p>This template makes the following design decisions regarding the default way Unity handles animation:</p>"},{"location":"systems/animation/#animation-system","title":"Animation system","text":"<p>This project uses Unity's default built-in animation system, known as the Mecanim Animation system, to bring its in-game units to life.</p>"},{"location":"systems/animation/#animation-folder","title":"Animation folder","text":"<p>The non-code files in this section are at <code>BeatEmUpTemplate/Assets/Animation</code>.</p>"},{"location":"systems/animation/#mecanimanimation","title":"MecanimAnimation","text":"<p>The non-code files in this section are in the <code>MecanimAnimation</code> subfolder.</p>"},{"location":"systems/animation/#animationclips","title":"AnimationClips","text":"<p>AnimationClips are imported from an external source or created within Unity. They are then placed and arranged in an AnimatorController.</p>"},{"location":"systems/animation/#animatorcontrollers","title":"AnimatorControllers","text":"<p>AnimatorControllers use state machines to determine what AnimationClip to play. They are referenced by the Animator components on the Hero and Villain prefabs. </p>"},{"location":"systems/animation/#scripting-folder","title":"Scripting folder","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Animation</code>.</p>"},{"location":"systems/animation/#statemachinebehaviours","title":"StateMachineBehaviours","text":"<p>These scripts are components that can be added to a state machine state. All classes in this folder derive from Unity's base StateMachineBehaviour class.</p>"},{"location":"systems/animation/#boolclearedbyipauseanimatorunpauseanimator","title":"BoolClearedByIPauseAnimatorUnpauseAnimator","text":"<pre><code>classDiagram\n    class BoolClearedByIPauseAnimatorUnpauseAnimator{\n    }</code></pre> <p><code>BoolClearedByIPauseAnimatorUnpauseAnimator.cs</code> defines a bool parameter to be cleared if the UnpauseAnimator event is fired by an IPauseAnimator interface implementation.</p>"},{"location":"systems/animation/#boolsetbyability","title":"BoolSetByAbility","text":"<pre><code>classDiagram\n    class BoolSetByAbility{\n    }</code></pre> <p><code>BoolSetByAbility.cs</code> define a bool parameter to be set if the SetAnimationBool event is fired by an IRaiseSetAnimationBool interface implementation. It also listens for when new abilities are added via a unit's AbilityManager.</p>"},{"location":"systems/animation/#boolsetbyidamageabledamaged","title":"BoolSetByIDamageableDamaged","text":"<pre><code>classDiagram\n    class BoolSetByIDamageableDamaged{\n    }</code></pre> <p><code>BoolSetByIDamageableDamaged.cs</code> defines a bool parameter to be set if the Damaged event is fired by an IDamageable interface implementation.</p>"},{"location":"systems/animation/#boolsetbyidamageabledamagedback","title":"BoolSetByIDamageableDamagedBack","text":"<pre><code>classDiagram\n    class BoolSetByIDamageableDamagedBack{\n    }</code></pre> <p><code>BoolSetByIDamageableDamagedBack.cs</code> defines a bool parameter to be set if the DamagedBack event is fired by an IDamageable interface implementation.</p>"},{"location":"systems/animation/#boolsetbyidefeatabledefeated","title":"BoolSetByIDefeatableDefeated","text":"<pre><code>classDiagram\n    class BoolSetByIDefeatableDefeated{\n    }</code></pre> <p><code>BoolSetByIDefeatableDefeated.cs</code> defines a bool parameter to be set if the Defeated event is fired by an IDefeatable interface implementation.</p>"},{"location":"systems/animation/#boolsetbyidefeatabledefeatedback","title":"BoolSetByIDefeatableDefeatedBack","text":"<pre><code>classDiagram\n    class BoolSetByIDefeatableDefeatedBack{\n    }</code></pre> <p><code>BoolSetByIDefeatableDefeatedBack.cs</code> defines a bool parameter to be set if the DefeatedBack event is fired by an IDefeatable interface implementation.</p>"},{"location":"systems/animation/#boolsetbyipauseanimatorpauseanimator","title":"BoolSetByIPauseAnimatorPauseAnimator","text":"<pre><code>classDiagram\n    class BoolSetByIPauseAnimatorPauseAnimator{\n    }</code></pre> <p><code>BoolSetByIPauseAnimatorPauseAnimator.cs</code> defines a bool parameter to be set if the PauseAnimator event is fired by an IPauseAnimator interface implementation.</p>"},{"location":"systems/animation/#boolsetbyiraisemoveexecutedmovement","title":"BoolSetByIRaiseMoveExecutedMovement","text":"<pre><code>classDiagram\n    class BoolSetByIRaiseMoveExecutedMovement{\n    }</code></pre> <p><code>BoolSetByIRaiseMoveExecutedMovement.cs</code> defines a bool parameter to be set if the MoveExecuted event is fired with a non-zero vector by an IRaiseMoveExecuted interface implementation.</p>"},{"location":"systems/animation/#boolsetbyiraisemoveexecutednomovement","title":"BoolSetByIRaiseMoveExecutedNoMovement","text":"<pre><code>classDiagram\n    class BoolSetByIRaiseMoveExecutedNoMovement{\n    }</code></pre> <p><code>BoolSetByIRaiseMoveExecutedNoMovement.cs</code> defines a bool parameter to be set if the MoveExecuted event is fired with a zero vector by an IRaiseMoveExecuted interface implementation.</p>"},{"location":"systems/animation/#boolsetbyiraisemoveexecutednonpositiveymovement","title":"BoolSetByIRaiseMoveExecutedNonPositiveYMovement","text":"<pre><code>classDiagram\n    class BoolSetByIRaiseMoveExecutedNonPositiveYMovement{\n    }</code></pre> <p><code>BoolSetByIRaiseMoveExecutedNonPositiveYMovement.cs</code> defines a bool parameter to be set if the MoveExecuted event is fired with a non-positive y-vector by an IRaiseMoveExecuted interface implementation.</p>"},{"location":"systems/animation/#boolsetbyiraisemoveexecutedpositiveymovement","title":"BoolSetByIRaiseMoveExecutedPositiveYMovement","text":"<pre><code>classDiagram\n    class BoolSetByIRaiseMoveExecutedPositiveYMovement{\n    }</code></pre> <p><code>BoolSetByIRaiseMoveExecutedPositiveYMovement.cs</code> defines a bool parameter to be set if the MoveExecuted event is fired with a positive y-vector by an IRaiseMoveExecuted interface implementation.</p>"},{"location":"systems/animation/#boolsetbyiraisewonwon","title":"BoolSetByIRaiseWonWon","text":"<pre><code>classDiagram\n    class BoolSetByIRaiseWonWon{\n    }</code></pre> <p><code>BoolSetByIRaiseWonWon.cs</code> defines a bool parameter to be set if the Won event is fired by an IRaiseWon interface implementation.</p>"},{"location":"systems/animation/#boolsetbyjumpability","title":"BoolSetByJumpAbility","text":"<pre><code>classDiagram\n    class BoolSetByJumpAbility{\n    }</code></pre> <p><code>BoolSetByJumpAbility.cs</code> defines a bool parameter to be set if the SetAnimationBool event is fired by a Jump ability.</p> <p>The difference between this script and BoolSetByAbility is that it correctly subscribes to the Jump ability even when two abilities are attached to the player's character at the same time. In the case of this template, even when the player is BeltScrollMoving.</p>"},{"location":"systems/animation/#boolsetonanimationfinished","title":"BoolSetOnAnimationFinished","text":"<pre><code>classDiagram\n    class BoolSetOnAnimationFinished{\n    }</code></pre> <p><code>BoolSetOnAnimationFinished.cs</code> defines a bool parameter to be set when the current state's animation finishes.</p>"},{"location":"systems/animation/#boolsetonstateexited","title":"BoolSetOnStateExited","text":"<pre><code>classDiagram\n    class BoolSetOnStateExited{\n    }</code></pre> <p><code>BoolSetOnStateExited.cs</code> defines a bool parameter to be set when the current state exits.</p>"},{"location":"systems/animation/#boolssetbyiraisemoveexecutednomovement","title":"BoolsSetByIRaiseMoveExecutedNoMovement","text":"<pre><code>classDiagram\n    class BoolsSetByIRaiseMoveExecutedNoMovement{\n    }</code></pre> <p><code>BoolsSetByIRaiseMoveExecutedNoMovement.cs</code> defines multiple bool parameters to be set when the MoveExecuted event is fired with a zero vector by an IRaiseMoveExecuted interface implementation.</p>"},{"location":"systems/animation/#boolssetonstateexited","title":"BoolsSetOnStateExited","text":"<pre><code>classDiagram\n    class BoolsSetOnStateExited{\n    }</code></pre> <p><code>BoolsSetOnStateExited.cs</code> defines multiple bool parameters to be set when the current state exits.</p>"},{"location":"systems/animation/#broadcastonstateexit","title":"BroadcastOnStateExit","text":"<pre><code>classDiagram\n    class BroadcastOnStateExit{\n    }</code></pre> <p><code>BroadcastOnStateExit.cs</code> fires a StateExited event when the current state exits.</p>"},{"location":"systems/animation/#triggersetbytimer","title":"TriggerSetByTimer","text":"<pre><code>classDiagram\n    class TriggerSetByTimer{\n    }</code></pre> <p><code>TriggerSetByTimer.cs</code> defines a trigger parameter to be triggered when a set amount of time has elapsed.</p>"},{"location":"systems/animation/#structs","title":"Structs","text":"<p>These scripts contain user-defined data types that combine fields of different types underneath a single type. All classes in this folder use the <code>struct</code> keyword in their declaration.</p>"},{"location":"systems/animation/#boolparameter","title":"BoolParameter","text":"<pre><code>classDiagram\n    class BoolParameter{\n    &lt;&lt;Struct&gt;&gt;\n    }</code></pre> <p><code>BoolParameter.cs</code> is used by StateMachineBehaviours to set a bool parameter with name 'name' to value 'value'.</p>"},{"location":"systems/audio/","title":"Audio","text":"<p>Summary</p> <p>This page summarizes all aspects of the audio system, which is responsible for playing dynamic background music and sound effects.</p>"},{"location":"systems/audio/#audio-folder","title":"Audio folder","text":"<p>The non-code files in this section are located at <code>BeatEmUpTemplate/Assets/Audio</code>.</p> <p>Each subfolder is named after the source of the AudioClips inside.</p>"},{"location":"systems/audio/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Audio</code>.</p>"},{"location":"systems/audio/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/audio/#audioevents","title":"AudioEvents","text":"<p><pre><code>classDiagram\n    class AudioEvents{\n        &lt;&lt;Static&gt;&gt;\n    }</code></pre> <code>AudioEvents.cs</code> contains all events related to audio. Events in this class are invoked whenever you need to signal a change in the game's audio. This includes things like changing the background music, playing a sound effect, or updating the volume.</p>"},{"location":"systems/audio/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/audio/#audiomanagers","title":"AudioManagers","text":"<pre><code>classDiagram\n    AudioManager &lt;|-- PersistentAudioManager\n    AudioManager &lt;|-- BootAudioManager\n    AudioManager &lt;|-- TitleAudioManager\n    AudioManager &lt;|-- StageAudioManager\n    class AudioManager{\n        &lt;&lt;Static&gt;&gt;\n    }</code></pre> <p>AudioManagers manage the background music and sound effects within a scene.</p> <p><code>AudioManager.cs</code> defines what is common across all AudioManagers, regardless of game. This includes things like maintaining a data structure of AudioSources to play.</p> <p><code>PersistentAudioManager.cs</code> defines AudioManager behaviour unique to the Persistent scene, like playing sound effects when the mouse enters a Button. This component can be found attached to the AudioManager GameObject in the Persistent scene.</p> <p><code>BootAudioManager.cs</code> defines AudioManager behaviour unique to the Boot scene, like playing sound effects when sections of the Company Logo are displayed. This component can be found attached to the AudioManager GameObject in the Boot scene.</p> <p><code>TitleAudioManager.cs</code> defines AudioManager behaviour unique to the Title scene, like playing sound effects when a coin is first inserted. This component can be found attached to the AudioManager GameObject in the Title scene.</p> <p><code>StageAudioManager.cs</code> defines AudioManager behaviour unique to stage scenes, like pausing audio when the game is paused. This component can be found attached to the AudioManager GameObject in the Training scene.</p> <p>Note</p> <p>For this template we've defined stages as scenes where the main gameplay takes place. For now this is just the Training scene, but the stage designation also includes any future levels.</p>"},{"location":"systems/command/","title":"Command","text":"<p>Summary</p> <p>This page summarizes all aspects of the command system, which is responsible for determining when in-game actions should be performed.</p>"},{"location":"systems/command/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Command</code>.</p>"},{"location":"systems/command/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/command/#commands","title":"Commands","text":"<pre><code>classDiagram\n    class Command{\n    }</code></pre> <p>Commands represent instances of UnitActions that can be queued for execution. A UnitActionManager requests a Command instance of a UnitAction from its ScriptableObject and then passes the Command to a CommandInvoker.</p> <p><code>Command.cs</code> defines what is common across all Commands, regardless of game. This includes things like references to its name, its user, and an execution method.</p>"},{"location":"systems/command/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/command/#commandinvokers","title":"CommandInvokers","text":"<pre><code>classDiagram\n    class CommandInvoker{\n    }</code></pre> <p>CommandInvokers invoke Commands for execution. A UnitActionManager requests a Command instance of a UnitActions from its ScriptableObject and then passes the Command to a CommandInvoker. </p> <p><code>CommandInvoker.cs</code> represents a basic, general-purpose CommandInvoker used by the template. It simply executes Commands as soon as it receives them instead of inserting them into any sort of queue. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/environment/","title":"Environment","text":"<p>Summary</p> <p>This page summarizes all aspects of the environment system, which is responsible for building immersive and responsive worlds.</p>"},{"location":"systems/environment/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Environment</code>.</p>"},{"location":"systems/environment/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/environment/#backgroundmanagers","title":"BackgroundManagers","text":"<pre><code>classDiagram\n    class BackgroundManager{\n    }</code></pre> <p>BackgroundManagers manage GameObjects that make up the background of a scene. This includes things like setting them active or inactive as needed.</p> <p><code>BackgroundManager.cs</code> manages the background GameObjects of the Title scene. It toggles its child GameObjects accordingly between the MainMenu and Options screens.</p>"},{"location":"systems/environment/#shadowcontrollers","title":"ShadowControllers","text":"<pre><code>classDiagram\n    class ShadowController{\n    }</code></pre> <p>ShadowControllers control the logic of shadows. This includes things like changing their size and opacity based on their user's distance to a surface.</p> <p><code>ShadowController.cs</code> represents a basic, general-purpose ShadowController used by the template. This component can be found attached to the Shadow prefab. These prefabs are instantiated as children of the ShadowManager GameObject in the Training scene at runtime.</p>"},{"location":"systems/environment/#shadowmanagers","title":"ShadowManagers","text":"<pre><code>classDiagram\n    class ShadowManager{\n    }</code></pre> <p>ShadowManagers manage the lifetimes of shadows. This includes things like registering and unregistering units to give them their own shadow.</p> <p><code>ShadowManager.cs</code> represents a basic, general-purpose ShadowManager used by the template. This component can be found attached to the ShadowManager GameObject in the Training scene.</p>"},{"location":"systems/game/","title":"Game","text":"<p>Summary</p> <p>This page summarizes all aspects of the game system, which is responsible for changing the game's state and directing its flow.</p>"},{"location":"systems/game/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Game</code>.</p>"},{"location":"systems/game/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/game/#constants","title":"Constants","text":"<pre><code>classDiagram\n    class Constants{\n    }</code></pre> <p><code>Constants.cs</code> contains all the constants in the template.</p>"},{"location":"systems/game/#gameevents","title":"GameEvents","text":"<pre><code>classDiagram\n    class GameEvents{\n        &lt;&lt;Static&gt;&gt;\n    }</code></pre> <p><code>GameEvents.cs</code> contains all events related to general game management. Events in this class are invoked whenever you need to signal or direct gameflow on the game's highest level. This includes things like pausing, running, resetting, or exiting the game.</p>"},{"location":"systems/game/#stageevents","title":"StageEvents","text":"<pre><code>classDiagram\n    class StageEvents{\n        &lt;&lt;Static&gt;&gt;\n    }</code></pre> <p><code>StageEvents.cs</code> contains all events related to stage management. Events in the StageEvent class are invoked whenever you need to signal or direct gameflow on a stage level. This includes things like triggering a loss or a win.</p> <p>Note</p> <p>For this template we've defined stages as scenes where the main gameplay takes place. For now this is just the Training scene, but the stage designation also includes any future levels.</p>"},{"location":"systems/game/#enums","title":"Enums","text":"<p>These scripts contain groups of related constants that are meant to be used by other scripts. All classes in these folders use the <code>enum</code> keyword in their declaration.</p>"},{"location":"systems/game/#direction","title":"Direction","text":"<pre><code>classDiagram\n    class Direction{\n    &lt;&lt;Enum&gt;&gt;\n    }</code></pre> <p><code>Direction.cs</code> enumerates the possible in-game directions in the template.</p>"},{"location":"systems/game/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/game/#gamemanagers","title":"GameManagers","text":"<pre><code>classDiagram\n    GameManager &lt;|-- PersistentGameManager\n    GameManager &lt;|-- StageGameManager\n    class GameManager{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>GameManagers control the changing state of the game.</p> <p><code>GameManager.cs</code> defines functionality common across all GameManagers, regardless of game. This includes a boolean that represents if a GameManager is currently in debug mode.</p> <p><code>PersistentGameManager.cs</code> defines game behaviour at the game level. This includes things like determining what to do when the game is reset or exited. This component can be found attached to the GameManager GameObject in the Persistent scene.</p> <p><code>StageGameManager.cs</code> defines game behaviour at the stage level. This includes things like determining what to do when the stage is paused, unpaused, or won. This component can be found attached to the GameManager object in the Training scene.</p> <p>Note</p> <p>For this template we've defined stages as scenes where the main gameplay takes place. For now this is just the Training scene, but the stage designation also includes any future levels.</p>"},{"location":"systems/game/#sceneloaders","title":"SceneLoaders","text":"<pre><code>classDiagram\n    class SceneLoader{\n    }</code></pre> <p>SceneLoaders load and unload scenes.</p> <p><code>SceneLoader.cs</code> represents a basic, general-purpose SceneLoader used by the template. This component can be found attached to the SceneLoader GameObject in the Persistent scene.</p>"},{"location":"systems/game/#unitbehaviours","title":"UnitBehaviours","text":"<p>UnitBehaviours are components attached to a unit prefab that represents its functionality.</p>"},{"location":"systems/game/#directionbehaviours","title":"DirectionBehaviours","text":"<pre><code>classDiagram\n    class DirectionBehaviour{\n    }</code></pre> <p>DirectionBehaviours describe the behaviour of a unit's Direction.</p> <p><code>DirectionBehaviour.cs</code> represents a basic, general-purpose DirectionBehaviour used by our template. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/hitbox/","title":"Hitbox","text":"<p>Summary</p> <p>This page summarizes all aspects of the hitbox system, which is responsible for transfering data between two bodies through collision detection.</p>"},{"location":"systems/hitbox/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Hitbox</code>.</p>"},{"location":"systems/hitbox/#enums","title":"Enums","text":"<p>These scripts contain groups of related constants that are meant to be used by other scripts. All classes in these folders use the <code>enum</code> keyword in their declaration.</p>"},{"location":"systems/hitbox/#hurtboxmask","title":"HurtboxMask","text":"<pre><code>classDiagram\n    class HurtboxMask{\n    &lt;&lt;Enum&gt;&gt;\n    }</code></pre> <p><code>HurtboxMask.cs</code> enumerates the possible HurtboxMasks a unit can have in the template. A unit's current HurtboxMask determines what HurtboxTypes a unit interacts with.</p>"},{"location":"systems/hitbox/#hurtboxtype","title":"HurtboxType","text":"<pre><code>classDiagram\n    class HurtboxType{\n    &lt;&lt;Enum&gt;&gt;\n    }</code></pre> <p><code>HurtboxType.cs</code> enumerates the possible types a Hurtbox can have in the template. Hitboxes only interact with Hurtboxes of specific types.</p>"},{"location":"systems/hitbox/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/hitbox/#hitboxes","title":"Hitboxes","text":"<pre><code>classDiagram\n    Hitbox &lt;|-- JabHitbox\n    Hitbox &lt;|-- CrossHitbox\n    class Hitbox{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>Hitboxes represent areas of an Ability that transmit data on collision with a Hurtbox.</p> <p><code>Hitbox.cs</code> defines what is common across all Hitboxes, regardless of game. This includes things like performing a boxcast in order to get information about how the hit occured.</p> <p><code>JabHitbox.cs</code> defines the hitbox for the Jab ability. This includes things like how it edits its JabAbilityData using information about the hit and the target.</p> <p><code>CrossHitbox.cs</code> defines the hitbox for the Cross ability. This includes things like how it edits its CrossAbilityData using information about the hit and the target.</p>"},{"location":"systems/hitbox/#hitdataeditors","title":"HitDataEditors","text":"<pre><code>classDiagram\n    class HitDataEditor{\n    }</code></pre> <p>HitDataEditors allow the user of an Ability a chance to edit its AbilityData pre and post hit.</p> <p><code>HitDataEditor.cs</code> represents a basic, general-purpose HitDataEditor used by the template. This component can be found attached to the Hitboxes GameObject under the Human prefab and its Hero and Villain prefab variants.</p>"},{"location":"systems/hitbox/#hitresponders","title":"HitResponders","text":"<pre><code>classDiagram\n    class HitResponder{\n    }</code></pre> <p>HitResponders respond when a unit's Hitbox triggers a collision with a Hurtbox.</p> <p><code>HitResponder.cs</code> represents a basic, general-purpose HitResponder used by the template. This component can be found attached to the Hitboxes GameObject under the Human prefab and its Hero and Villain prefab variants.</p>"},{"location":"systems/hitbox/#hurtboxes","title":"Hurtboxes","text":"<pre><code>classDiagram\n    class Hurtbox{\n    }</code></pre> <p>Hurtboxes represent areas that trigger collisions with Hitboxes.</p> <p><code>Hurtbox.cs</code> defines what is common across all Hurtboxes, regardless of game. This includes things like having a class field that represents its HurtboxType.</p>"},{"location":"systems/hitbox/#hurtdataeditors","title":"HurtDataEditors","text":"<pre><code>classDiagram\n    class HurtDataEditor{\n    }</code></pre> <p>HurtDataEditors allow the target of an Ability a chance to edit its AbilityData post hit.</p> <p><code>HurtDataEditor.cs</code> represents a basic, general-purpose HurtDataEditor used by the template. This component can be found attached to the Hurtboxes GameObject under the Human prefab and its Hero and Villain prefab variants.</p>"},{"location":"systems/hitbox/#hurtresponders","title":"HurtResponders","text":"<pre><code>classDiagram\n    class HurtResponder{\n    }</code></pre> <p>HurtResponders respond when a unit's Hurtbox triggers a collision with a Hitbox.</p> <p><code>HurtResponder.cs</code> represents a basic, general-purpose HurtResponder used by the template. This component can be found attached to the Hurtboxes GameObject under the Human prefab and its Hero and Villain prefab variants.</p>"},{"location":"systems/hitbox/#unitbehaviours","title":"UnitBehaviours","text":"<p>UnitBehaviours are components attached to a unit prefab that represents its functionality.</p>"},{"location":"systems/hitbox/#hurtboxmaskbehaviours","title":"HurtboxMaskBehaviours","text":"<pre><code>classDiagram\n    class HurtboxMaskBehaviour{\n    }</code></pre> <p>HurtboxMaskBehaviours describe the behaviour of a unit's HurtboxMask.</p> <p><code>HurtboxMaskBehaviour.cs</code> represents a basic, general-purpose HurtboxMaskBehaviour used by our template. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/hitbox/#structs","title":"Structs","text":"<p>These scripts contain user-defined data types that combine fields of different types underneath a single type. All classes in this folder use the <code>struct</code> keyword in their declaration.</p>"},{"location":"systems/hitbox/#hitpacket","title":"HitPacket","text":"<pre><code>classDiagram\n    class HitPacket{\n    &lt;&lt;Struct&gt;&gt;\n    }</code></pre> <p><code>HitPacket.cs</code> contains all the information involved in a hit, including the AbilityData being transferred.</p>"},{"location":"systems/input/","title":"Input","text":"<p>Summary</p> <p>This page summarizes all aspects of the input system, which is responsible for switching between different control schemes.</p>"},{"location":"systems/input/#design-decisions","title":"Design decisions","text":"<p>This template makes the following design decisions regarding the default way Unity handles input:</p>"},{"location":"systems/input/#input-system","title":"Input system","text":"<p>Unity\u2019s legacy input system is called the Input Manager. It is built into the Editor and is part of the core Unity platform. It is enabled by default.</p> <p>In 2020 Unity released a new input system called the Input System package. It is more flexible than the basic Input Manager as it allows any kind of Input Device to control Unity content. It must be installed manually through the Package Manager, after which it can either deactivate the older Input Manager or work alongside it.</p> <p>Warning</p> <p>Unity currently recommends using the new Input System package since they plan on removing the legacy Input Manager in the future.</p> <p>This template uses Unity's new Input System package. See Unity\u2019s sample project Warriors for a full demonstration of the Input System\u2019s tools and functionality.</p>"},{"location":"systems/input/#input-folder","title":"Input folder","text":"<p>The non-code files in this section are at <code>BeatEmUpTemplate/Assets/WorkingInUnity/Input</code>.</p>"},{"location":"systems/input/#inputsystem","title":"InputSystem","text":"<p>The non-code files in this section are in the <code>InputSystem</code> subfolder.</p>"},{"location":"systems/input/#inputactionasset","title":"InputActionAsset","text":"<p><code>Controls.inputactions</code>is an InputActionAsset file that contains a set of Input Actions definitions and their associated Bindings and Control Schemes.</p>"},{"location":"systems/input/#inputsettings","title":"InputSettings","text":"<p><code>InputSystem.inputsettings</code> is an InputSettings file that represents the Input System configuration for the template. You can edit this configuration manually at <code>Edit/Project Settings/Input System Package/Settings</code>.</p>"},{"location":"systems/input/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Input</code>.</p>"},{"location":"systems/input/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/input/#inputevents","title":"InputEvents","text":"<pre><code>classDiagram\n    class InputEvents{\n    }\n    class TitleInputEvents{\n    }</code></pre> <p>InputEvents contain all events related to input.</p> <p><code>InputEvents.cs</code> contains all events related to general input. This includes things like enabling or disabling all or specific player input action maps.</p> <p><code>TitleInputEvents.cs</code> contains all events related to input in the Title scene. This includes things like notifying other classes when the keybinding process has started or completed.</p>"},{"location":"systems/input/#enums","title":"Enums","text":"<p>These scripts contain groups of related constants that are meant to be used by other scripts. All classes in these folders use the <code>enum</code> keyword in their declaration.</p>"},{"location":"systems/input/#actionmap","title":"ActionMap","text":"<pre><code>classDiagram\n    class ActionMap{\n    &lt;&lt;Enum&gt;&gt;\n    }</code></pre> <p><code>ActionMap.cs</code> enumerates all Action Maps in the InputActionAsset being used by players.</p>"},{"location":"systems/input/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/input/#inputactionmapcontrollers","title":"InputActionMapControllers","text":"<pre><code>classDiagram\n    InputActionMapController &lt;|-- BootInputActionMapController\n    InputActionMapController &lt;|-- TitleInputActionMapController\n    InputActionMapController &lt;|-- StageInputActionMapController\n    class InputActionMapController{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>InputActionMapControllers control the behaviour of PlayerInput action maps within a scene.</p> <p><code>InputActionMapController.cs</code> defines what is common across all InputActionMapControllers, regardless of game. This includes things like keeping a data structure of all PlayerManagers that the controller can modify.</p> <p><code>BootInputActionMapController.cs</code> defines InputActionMapController behaviour unique to the Boot scene. This includes things like enabling or disabling maps when a player joins or the Title scene finishes preloading. This component can be found attached to the InputActionMapController GameObject in the Boot scene.</p> <p><code>TitleInputActionMapController.cs</code> defines InputActionMapController behaviour unique to the Title scene. Things includes things like rebinding keys from the Options menu. This component can be found attached to the InputActionMapController GameObject in the Title scene.</p> <p><code>StageInputActionMapController.cs</code> defines InputActionMapController behaviour unique to stage scenes. This includes things like enabling or disabling maps on stage win, lose, continue, game over, and win. This component can be found attached to the InputActionMapController GameObject in the Stage scene.</p> <p>Note</p> <p>For this template we've defined stages as scenes where the main gameplay takes place. For now this is just the Training scene, but the stage designation also includes any future levels.</p>"},{"location":"systems/player/","title":"Player","text":"<p>Summary</p> <p>This page summarizes all aspects of the player system, which is responsible for managing both human and AI players.</p>"},{"location":"systems/player/#design-decisions","title":"Design decisions","text":"<p>This template makes the following design decisions regarding the default way Unity handles players:</p>"},{"location":"systems/player/#player-system","title":"Player system","text":"<p>Unity's local player system is managed through their Input System package by a component called the Player Input Manager. It automatically manages the creation and lifetime of PlayerInput instances as players join and leave the game.</p> <p>For this template we have opted not to use Unity's default Player Input Manager component. This is because we want our human players and AI players to be handled separately. This template uses custom PlayerManagers for this purpose. Virtual devices are created for AI players so that their inputs can be handled the same way as human players.</p>"},{"location":"systems/player/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Player</code>.</p>"},{"location":"systems/player/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/player/#humanplayerevents","title":"HumanPlayerEvents","text":"<pre><code>classDiagram\n    class HumanPlayerEvents{\n        &lt;&lt;Static&gt;&gt;\n    }</code></pre> <p><code>HumanPlayerEvents.cs</code> contains all events related to human players. This includes things like joining the game, pressing any key, clicking, or toggling pause.</p>"},{"location":"systems/player/#players","title":"Players","text":"<pre><code>classDiagram\n    Player &lt;|-- AIPlayer</code></pre> <p>Players represent entities capable of playing the game by giving it inputs. This includes both human players and AI players.</p> <p><code>Player.cs</code> defines what is common across all players regardless of game or whether they are human or AI. This includes things like having an assigned ID and a reference to their assigned PlayerInput component.</p> <p><code>AIPlayer.cs</code> defines what is unique to AI players, regardless of game. This includes a reference to the AI component that controls their logic.</p>"},{"location":"systems/player/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/player/#ais","title":"AIs","text":"<pre><code>classDiagram\n    AI &lt;|-- BasicEnemyAI</code></pre> <p>AIs are components attached to AIPlayer prefabs that determine how they play the game.</p> <p><code>AI.cs</code> defines what is common across all AI regardless of game and whether they are enemies or allies. This includes things like assigning its PlayerInput and UnitController components.</p> <p><code>BasicEnemyAI.cs</code> represents a basic enemy AI that moves to the closest human player unit and performs a basic attack. It repeats this behaviour until there are no more targets left or it is defeated. This component can be found attached to AIPlayer prefab. These prefabs are instantiated as children of the AIPlayerManager GameObject in the Training scene at runtime.</p>"},{"location":"systems/player/#humanplayercontrollers","title":"HumanPlayerControllers","text":"<pre><code>classDiagram\n    class HumanPlayerController{\n    }</code></pre> <p>HumanPlayerControllers determine what HumanPlayerEvents are invoked when that human player performs a specific input action.</p> <p><code>HumanPlayerController.cs</code> represents a basic human player controller. This component can be found attached to the HumanPlayer prefab. These prefabs are instantiated as children of the HumanPlayerManager GameObject in the Persistent scene at runtime.</p>"},{"location":"systems/player/#playermanagers","title":"PlayerManagers","text":"<pre><code>classDiagram\n    PlayerManager &lt;|-- HumanPlayerManager\n    PlayerManager &lt;|-- AIPlayerManager\n    AIPlayerManager &lt;|-- TrainingAIPlayerManager\n    class PlayerManager{\n        &lt;&lt;Abstract&gt;&gt;\n    }\n    class AIPlayerManager{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>PlayerManagers are custom scripts that manage human and AI Players, replacing Unity's default Player Input Manager component.</p> <p><code>PlayerManager.cs</code> defines what is common across all PlayerManagers, regardless of game. This includes things like maintaining a data structure for the players and defining the maximum number of players it can manage.</p> <p><code>HumanPlayerManager.cs</code> defines what is common across all PlayerManagers that manage only humans. This includes detecting the usage of unpaired devices and adding a new human player. This component can be found attached to the HumanPlayerManager GameObject in the Persistent scene.</p> <p><code>AIPlayerManager.cs</code> defines what is common across all PlayerManagers that manage only AI. This includes creating virtual devices for AI players to use when adding them.</p> <p><code>TrainingAIPlayerManager.cs</code> defines AIPlayerManager behaviour unique to the Training scene. This includes spawning AI player units on Awake() and stopping them when the stage is lost. This component can be found attached to the AIPlayerManager GameObject in the Training scene.</p>"},{"location":"systems/ui/","title":"UI","text":"<p>Summary</p> <p>This page summarizes all aspects of the user interface (UI) system, which is responsible for designing custom menus and transitions.</p>"},{"location":"systems/ui/#design-decisions","title":"Design decisions","text":"<p>This template makes the following design decisions regarding the default way Unity handles UI:</p>"},{"location":"systems/ui/#ui-system","title":"UI system","text":"<p>Unity UI (uGUI) is one of Unity\u2019s core packages. It is a GameObject-based UI system that uses Components and the Game View to arrange, position, and style user interfaces. Because it is a runtime-GUI system it cannot be used to create or change user interfaces in the Unity Editor.</p> <p>In 2021 Unity released a new UI system called UI Toolkit. Inspired by standard web technologies, it was designed to be used by anyone who has experience developing web pages or applications since the knowledge is transferable and the core concepts are familiar. Unlike uGUI, UI Toolkit can create both runtime and Editor UI. </p> <p>Warning</p> <p>Unity currently recommends using UIToolkit since they plan on removing the legacy uGUI in the future.</p> <p>Info</p> <p>The current release of UI Toolkit does not have some features that uGUI can still support. Some older, legacy projects may also still use uGUI. Check out Unity's official comparison of the two UI systems.</p> <p>This template uses Unity's new UI Toolkit system. See Unity\u2019s sample projects QuizU and Dragon Crashers for a full demonstration of UI Toolkit's tools and functionality.</p>"},{"location":"systems/ui/#cursor","title":"Cursor","text":"<p>In Unity the default hardware cursor can be set at <code>Edit &gt; Project Settings &gt; Player</code> where a custom Texture 2D can be assigned. It can then be controlled using Unity's built-in Cursor API. This sprite, however, cannot be scaled dynamically and is limited to a dimension of 32x32 on Windows.</p> <p>To change this we have created our own custom CursorController. It is a software cursor (so it will lag slightly behind compared to the default hardware cursor) that can scale dynamically and has no size limit.</p>"},{"location":"systems/ui/#ui-folder","title":"UI folder","text":"<p>The non-code files in this section are at <code>BeatEmUpTemplate/Assets/WorkingInUnity/UI</code>.</p>"},{"location":"systems/ui/#ui-toolkit","title":"UI Toolkit","text":"<p>The non-code files in this section are in the <code>UIToolkit</code> subfolder.</p>"},{"location":"systems/ui/#fonts","title":"Fonts","text":"<p>Each font subfolder contains its license, its font, and its font assets. Font assets act as containers for fonts so that they can serve as the basis for variations without changing the original font.</p> <p>This template only uses one font: <code>PressStart2P-Regular.ttf</code>.</p>"},{"location":"systems/ui/#panelsettings","title":"PanelSettings","text":"<p>PanelSettings assets instantiate panels at runtime, where Unity displays UXML-file based UI in the Game view. UIDocument components need a reference to a PanelSettings asset so that they know which panel to display their content on.</p> <p><code>UIPanelSettings.asset</code> defines the bottom panel, which is used for UIViews and the great majority of the user interface. It is referenced by the UIDocument component on the UIManager GameObject in the Boot, TItle, and Training scenes.</p> <p><code>CursorPanelSettings.asset</code> defines the middle panel, which is used for the mouse cursor that exists above the UI but below screen transitions. It is referenced by the UIDocument component on the Cursor GameObject in the Persistent scene.</p> <p><code>PersistentPanelSettings.asset</code> defines the top panel, which is used for screen transitions. It is referenced by the UIDocument component on the UIManager GameObject in the Persistent scene.</p>"},{"location":"systems/ui/#themestylesheets","title":"ThemeStyleSheets","text":"<p>ThemeStyleSheet files are USS files that Unity uses for management purposes. They are referenced by PanelSettings assets and applied to their panels.</p> <p><code>UnityDefaultRuntimeTheme.tss</code> is the default ThemeStyleSheet that is automatically created by Unity when the first UIDocument is added to a GameObject.</p>"},{"location":"systems/ui/#visualtrees","title":"VisualTrees","text":"<p>VisualTree files depict hierarchy relationships between VisualElements. They can represent scenes, screens, or even custom VisualElements themselves. VisualTrees are created via <code>Assets &gt; Create &gt; UI Toolkit &gt; UI Document</code>.</p> <p>When a VisualTree is created in UIBuilder it automatically generates the underlying Unity Extensible Markup Language (UXML) and UnityStyleSheet (USS) code while providing a preview for reference. UXML and USS are UIToolkit equivalents to HTML and CSS in web design and have similar functionality by design.</p> <p>VisualTrees representing entire scenes are referenced by the UIDocument component on the UIManager GameObject in the Persistent, Boot, TItle, and Training scenes.</p>"},{"location":"systems/ui/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/UI</code>.</p>"},{"location":"systems/ui/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/ui/#uievents","title":"UIEvents","text":"<pre><code>classDiagram\n    class PersistentUIEvents{\n    }\n    class BootUIEvents{\n    }\n    class TitleUIEvents{\n    }\n    class StageUIEvents{\n    }</code></pre> <p>UIEvents contain all events related to the user interface.</p> <p><code>PersistentUIEvents.cs</code> contains all UIEvents unique to the Persistent scene. This includes things like fade transitions which exist on the persistent level and can be invoked from any scene. </p> <p><code>BootUIEvents.cs</code> contains all UIEvents unique to the Boot scene. This includes things like signaling when sections of the Company Logo have been displayed or when the Title scene has been successfully preloaded.</p> <p><code>TitleUIEvents.cs</code> contains all UIEvents unique to the Title scene. This includes things like signaling when menu options are moused over or clicked.</p> <p><code>StageUIEvents.cs</code> contains all UIEvents unique to Stage scenes. This includes things like showing the pause screen or updating player health bars.</p> <p>Note</p> <p>For this template we've defined stages as scenes where the main gameplay takes place. For now this is just the Training scene, but the stage designation also includes any future levels.</p>"},{"location":"systems/ui/#uiviews","title":"UIViews","text":"<pre><code>classDiagram\n    UIView &lt;|-- UGUIView\n    UIView &lt;|-- UIToolkitView\n    UGUIView &lt;|-- SplashView\n    UIToolkitView &lt;|-- FaderView\n    UIToolkitView &lt;|-- MainMenuView\n    UIToolkitView &lt;|-- OptionsView\n    UIToolkitView &lt;|-- GameplayView\n    UIToolkitView &lt;|-- PauseView\n    UIToolkitView &lt;|-- ContinueView\n    UIToolkitView &lt;|-- GameOverView\n    UIToolkitView &lt;|-- CompleteView\n    class UIView{\n        &lt;&lt;Abstract&gt;&gt;\n    }\n    class UGUIView{\n        &lt;&lt;Abstract&gt;&gt;\n    }\n    class UIToolkitView{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>UIViews contain the various elements that make up the user interface for each screen. They communicate with their respective ScreenController using UIEvents classes to create an interactive user interface.</p> <p>The UIView class has two direct children: UGUIView and UIToolkitView. These classes are used to create views for Unity's uGUI and UI Toolkit systems, respectively.</p>  UIView Represents Used by Works with Using <code>FaderView</code> Fader screen Persistent scene FaderScreenController PersistentUIEvents <code>SplashView</code> Splash screen Boot scene SplashScreenController BootUIEvents <code>MainMenuView</code> MainMenu screen Title scene MainMenuScreenController TitleUIEvents <code>OptionsView</code> Options screen Title scene OptionsScreenController TitleUIEvents <code>GameplayView</code> Gameplay screen Stage scenes GameplayScreenController StageUIEvents <code>PauseView</code> Pause screen Stage scenes PauseScreenController StageUIEvents <code>ContinueView</code> Continue screen Stage scenes ContinueScreenController StageUIEvents <code>GameOverView</code> GameOver screen Stage scenes GameOverScreenController StageUIEvents <code>CompleteView</code> Complete screen Stage scenes CompleteScreenController StageUIEvents <p>Note</p> <p>For this template we've defined stages as scenes where the main gameplay takes place. For now this is just the Training scene, but the stage designation also includes any future levels.</p>"},{"location":"systems/ui/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/ui/#cursorcontrollers","title":"CursorControllers","text":"<pre><code>classDiagram\n    class CursorController{\n    }</code></pre> <p>CursorControllers control the logic of the software cursor sprite. This includes things like dynamically updating its position, size, and visibility.</p> <p><code>CursorController.cs</code> represents a basic, general-purpose CursorController used by the template. This component can be found attached to the Cursor GameObject in the Persistent scene.</p>"},{"location":"systems/ui/#floatinghealthbarcontrollers","title":"FloatingHealthBarControllers","text":"<pre><code>classDiagram\n    class FloatingHealthBarController{\n    }</code></pre> <p>FloatingHealthBarControllers control the logic of floating health bars. This includes things like updating the floating health bar's position to follow a specific unit.</p> <p><code>FloatingHealthBarController.cs</code> represents a basic, general-purpose FloatingHealthBarController used by the template. This component can be found attached to the FloatingHealthBar prefab. These prefabs are instantiated as children of the FloatingHealthBarManager GameObject in the Training scene at runtime.</p>"},{"location":"systems/ui/#floatinghealthbarmanagers","title":"FloatingHealthBarManagers","text":"<pre><code>classDiagram\n    class FloatingHealthBarManager{\n    }</code></pre> <p>FloatingHealthBarManagers manage the lifetimes of floating health bars. This includes things like registering and unregistering units to give them their own floating health bar.</p> <p><code>FloatingHealthBarManager.cs</code> represents a basic, general-purpose FloatingHealthBarManager used by the template. This component can be found attached to the FloatingHealthBarManager GameObject in the Training scene.</p>"},{"location":"systems/ui/#screencontrollers","title":"ScreenControllers","text":"<p><pre><code>classDiagram\n    class FaderScreenController{\n    }\n    class SplashScreenController{\n    }\n    class MainMenuScreenController{\n    }</code></pre> <pre><code>classDiagram\n    class OptionsScreenController{\n    }\n    class GameplayScreenController{\n    }\n    class PauseScreenController{\n    }</code></pre> <pre><code>classDiagram\n    class ContinueScreenController{\n    }\n    class GameOverScreenController{\n    }\n    class CompleteScreenController{\n    }</code></pre></p> <p>ScreenControllers control the logic of a screen used by a scene. This includes things like determining what happens when a specific button is clicked. They communicate with their respective UIView using UIEvents classes to create an interactive user interface. These components can be found attached to GameObjects of the same name that are children of the ScreenControllers GameObject in their respective scenes.</p>  UIView Controls logic for Used by Works with Using <code>FaderScreenController</code> Fader screen Persistent scene FaderView PersistentUIEvents <code>SplashScreenController</code> Splash screen Boot scene SplashView BootUIEvents <code>MainMenuScreenController</code> MainMenu screen Title scene MainMenuView TitleUIEvents <code>OptionsScreenController</code> Options screen Title scene OptionsView TitleUIEvents <code>GameplayScreenController</code> Gameplay screen Stage scenes GameplayView StageUIEvents <code>PauseScreenController</code> Pause screen Stage scenes PauseView StageUIEvents <code>ContinueScreenController</code> Continue screen Stage scenes ContinueView StageUIEvents <code>GameOverScreenController</code> GameOver screen Stage scenes GameOverView StageUIEvents <code>CompleteScreenController</code> Complete screen Stage scenes CompleteView StageUIEvents <p>Note</p> <p>For this template we've defined stages as scenes where the main gameplay takes place. For now this is just the Training scene, but the stage designation also includes any future levels.</p>"},{"location":"systems/ui/#uguicontrollers","title":"UGUIControllers","text":"<p>UGUIControllers are components attached to a uGUI GameObject that represent its logic.</p>"},{"location":"systems/ui/#companylogocontroller","title":"CompanyLogoController","text":"<pre><code>classDiagram\n    class CompanyLogoController{\n    }</code></pre> <p>CompanyLogoController.cs is responsible for directing the animation of the company logo.</p>"},{"location":"systems/ui/#uimanagers","title":"UIManagers","text":"<pre><code>classDiagram\n    UIManager &lt;|-- PersistentUIManager\n    UIManager &lt;|-- BootUIManager\n    UIManager &lt;|-- TitleUIManager\n    UIManager &lt;|-- StageUIManager\n    StageUIManager &lt;|-- TrainingUIManager\n    class UIManager{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>UIManagers manage the lifetimes of UIViews within a scene. This includes things like creating, showing, and hiding screens when needed.</p> <p><code>UIManager.cs</code> defines what is common across all UIManagers, regardless of game. This includes things like referencing a Canvas (for uGUI) or UIDocument (for UI Toolkit), and maintaining a data structure that contains all the UIViews its managing.</p> <p><code>PersistentUIManager.cs</code> defines UIManager behaviour unique to the Persistent scene, like showing the Fader screen for fade-from or fade-to transitions. This component can be found attached to the UIManager GameObject in the Persistent scene.</p> <p><code>BootUIManager.cs</code> defines UIManager behaviour unique to the Boot scene, like showing the Splash screen by default. This component can be found attached to the UIManager GameObject in the Boot scene.</p> <p><code>TitleUIManager.cs</code> defines UIManager behaviour unique to the Title scene, like toggling between the MainMenu screen and the Options screen. This component can be found attached to the UIManager GameObject in the Title scene.</p> <p><code>StageUIManager.cs</code> defines UIManager behaviour unique to stage scenes, like showing the Gameplay screen by default or toggling between the Pause, Continue, GameOver and Complete screens.</p> <p><code>TrainingUIManager.cs</code> defines UIManager behaviour unique to the Training scene, like changing the text color in the footer to suit the background. This component can be found attached to the UIManager GameObject in the Training scene.</p> <p>Note</p> <p>For this template we've defined stages as scenes where the main gameplay takes place. For now this is just the Training scene, but the stage designation also includes any future levels.</p>"},{"location":"systems/ui/#visualelements","title":"VisualElements","text":"<p>These scripts contain objects that are part of the UIElements visual tree and inherit from Unity's base VisualElement class.</p>"},{"location":"systems/ui/#healthbar","title":"HealthBar","text":"<pre><code>classDiagram\n    class HealthBar{\n    }</code></pre> <p><code>HealthBar.cs</code> is a custom VisualElement that represents a unit's health. The size of its foreground element relative to its background element visually indicates a unit's current health relative to its maximum health. It can fill either horizontally or vertically.</p>"},{"location":"systems/unit/","title":"Unit","text":"<p>Summary</p> <p>This page summarizes all aspects of the unit system, which is responsible for creating, customizing, and managing the lifetime of in-game units.</p>"},{"location":"systems/unit/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Unit</code>.</p>"},{"location":"systems/unit/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/unit/#teams","title":"Teams","text":"<pre><code>classDiagram\n    class Team{\n    }</code></pre> <p>Teams represent groups of allied units. A single team can have both human player units and AI player units.</p> <p><code>Team.cs</code> defines what is common across all teams regardless of game. This includes things like having a team name and having a data structure that manages its members.</p>"},{"location":"systems/unit/#unitmanagerevents","title":"UnitManagerEvents","text":"<pre><code>classDiagram\n    class UnitManagerEvents{\n        &lt;&lt;Static&gt;&gt;\n    }</code></pre> <p><code>UnitManagerEvents.cs</code> contains all events related to unit management. This includes things like signaling when human player units or AI player units spawn.</p>"},{"location":"systems/unit/#enums","title":"Enums","text":"<p>These scripts contain groups of related constants that are meant to be used by other scripts. All classes in these folders use the <code>enum</code> keyword in their declaration.</p>"},{"location":"systems/unit/#unit_1","title":"Unit","text":"<pre><code>classDiagram\n    class Unit{\n    &lt;&lt;Enum&gt;&gt;\n    }</code></pre> <p><code>Unit.cs</code> enumerates all possible units in the template.</p>"},{"location":"systems/unit/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/unit/#teammanagers","title":"TeamManagers","text":"<pre><code>classDiagram\n    class TeamManager{\n    }</code></pre> <p>TeamManagers manage the lifetime of teams. This includes things like creating team prefabs and maintaining a data structure that contains the teams.</p> <p><code>TeamManager.cs</code> represents a basic, general-purpose TeamManager used by the template. This component can be found attached to the TeamManager GameObject in the Training scene.</p>"},{"location":"systems/unit/#unitbehaviours","title":"UnitBehaviours","text":"<p>UnitBehaviours are components attached to a unit prefab that represents its functionality.</p>"},{"location":"systems/unit/#crowdcontrolbehaviours","title":"CrowdControlBehaviours","text":"<pre><code>classDiagram\n    class CrowdControlBehaviour{\n    }</code></pre> <p>CrowdControlBehaviours describe the behaviour of a unit when it is crowd controlled.</p> <p><code>CrowdControlBehaviour.cs</code> represents a basic, general-purpose CrowdControlBehaviour used by the template. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/unit/#healthbehaviours","title":"HealthBehaviours","text":"<pre><code>classDiagram\n    class HealthBehaviour{\n    }</code></pre> <p>HealthBehaviours describe the behaviour of a unit's health.</p> <p><code>HealthBehaviour.cs</code> represents a basic, general-purpose HealthBehaviour used by the template. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/unit/#namebehaviours","title":"NameBehaviours","text":"<pre><code>classDiagram\n    class NameBehaviour{\n    }</code></pre> <p>NameBehaviours describe the behaviour of a unit's name.</p> <p><code>NameBehaviour.cs</code> represents a basic, general-purpose NameBehaviour used by the template. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/unit/#statuseffectbehaviours","title":"StatusEffectBehaviours","text":"<pre><code>classDiagram\n    class StatusEffectBehaviour{\n    }</code></pre> <p>StatusEffectBehaviours describe the behaviour of a unit when it is affected by status effects.</p> <p><code>StatusEffectBehaviour.cs</code> represents a basic, general-purpose StatusEffectBehaviour used by the template. This component can be found attached to the Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/unit/#unitcontrollers","title":"UnitControllers","text":"<pre><code>classDiagram\n    UnitController &lt;|-- HeroController\n    UnitController &lt;|-- VillainController\n    class UnitController{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>UnitControllers control the logic of specific units.</p> <p><code>UnitController.cs</code> defines what is common across all UnitControllers, regardless of game. This includes things like setting the units initial stats based off its referenced UnitStats file.</p> <p><code>HeroController.cs</code> defines behaviour unique to the Hero unit. This includes things like facing the Direction the player has their unit move. This component can be found attached to the Hero prefab, which is instantiated as a child of the HumanPlayerUnitManager GameObject in the Training scene at runtime.</p> <p><code>VillainController.cs</code> defines behaviour unique to the Villain unit. This includes things like determining what to do in response to the attack input action. This component can be found attached to the Villain prefab, which is instantiated as a child of the AIPlayerUnitManager GameObject in the Training scene at runtime.</p>"},{"location":"systems/unit/#unitfactories","title":"UnitFactories","text":"<pre><code>classDiagram\n    class UnitFactory{\n    }</code></pre> <p>UnitFactories load and release addressable unit prefab assets.</p> <p><code>UnitFactory.cs</code> represents a basic, general-purpose UnitFactory used by the template. This component can be found attached to the UnitFactory GameObject in the Persistent scene.</p>"},{"location":"systems/unit/#unitmanagers","title":"UnitManagers","text":"<pre><code>classDiagram\n    UnitManager &lt;|-- HumanPlayerUnitManager\n    UnitManager &lt;|-- AIPlayerUnitManager\n    HumanPlayerUnitManager &lt;|-- TrainingHumanPlayerUnitManager\n    AIPlayerUnitManager &lt;|-- TrainingAIPlayerUnitManager\n    class UnitManager{\n        &lt;&lt;Abstract&gt;&gt;\n    }\n    class HumanPlayerUnitManager{\n        &lt;&lt;Abstract&gt;&gt;\n    }\n    class AIPlayerUnitManager{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>UnitManagers are scripts that manage human and AI player units.</p> <p><code>UnitManager.cs</code> defines what is common across all UnitManagers, regardless of game. This includes things like spawning units.</p> <p><code>HumanPlayerUnitManager.cs</code> defines what is common across all UnitManagers that manage only human player units. This includes things like signaling whenever a human player unit was spawned. </p> <p><code>AIPlayerUnitManager.cs</code> defines what is common across all UnitManagers that manage only AI player units. This includes things like signaling whenever an AI player unit was spawned.</p> <p><code>TrainingHumanPlayerUnitManager.cs</code> manages the lifetime of human player units in the Training scene. This includes signaling a stage loss once all human player units have been defeated. This component can be found attached to the HumanPlayerUnitManager GameObject in the Training scene.</p> <p><code>TrainingAIPlayerUnitManager.cs</code> manages the lifetime of AI player units in the Training scene. This includes signaling a stage win once the defeated animation for all AI player units have finished. This component can be found attached to the AIPlayerUnitManager GameObject in the Training scene.</p>"},{"location":"systems/unit/#scriptableobjects","title":"ScriptableObjects","text":"<p>These scripts contain centralized data that can be conveniently accessed from scenes and assets within a project. All classes in this folder derive from Unity's base ScriptableObject class.</p> <p>ScriptableObjects are stored on disk and live independently of GameObjects and class instances. They are used as data containers to save large amounts of data, reducing a project\u2019s memory usage by not duplicating values.</p>"},{"location":"systems/unit/#unitstats","title":"UnitStats","text":"<pre><code>classDiagram\n    class UnitStats{\n    }</code></pre> <p><code>UnitStats.cs</code> represents the innate statistics of a unit. This includes things like name, maximum health, and walk speed.</p>"},{"location":"systems/utilities/","title":"Utilities","text":"<p>Summary</p> <p>This page outlines the utilitiy scripts used by the 2.5D Beat 'Em Up Template. These classes don't belong to any one game system and act as general-purpose tools that can be used anywhere, in any game, when needed. </p>"},{"location":"systems/utilities/#scripting","title":"Scripting","text":"<p>The code files in this section are at <code>BeatEmUpTemplate/Assets/Scripting/Utilities</code>.</p>"},{"location":"systems/utilities/#csharp","title":"CSharp","text":"<p>These scripts are not meant to be attached to GameObjects in the scene. Many of them represent static event classes that are meant to be invoked or are abstract classes representing concepts.</p>"},{"location":"systems/utilities/#actionwrapper","title":"ActionWrapper","text":"<pre><code>classDiagram\n    class ActionWrapper{\n    }</code></pre> <p><code>ActionWrapper.cs</code> is used by PersistentGameManager to define the EventLinks in its StateMachine. It essentially connects two nodes in the StateMachine through subscriptions to GameEvents.</p>"},{"location":"systems/utilities/#statemachine","title":"StateMachine","text":"<pre><code>classDiagram\n    class StateMachine{\n    }</code></pre> <p><code>StateMachine.cs</code> represents a basic, general-purpose state machine. It is used by PersistentGameManager to represent the game's state.</p>"},{"location":"systems/utilities/#ilink","title":"ILink","text":"<pre><code>classDiagram\n    class ILink{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>ILink.cs</code> is used by IStates to add a link to another IState.</p>"},{"location":"systems/utilities/#istate","title":"IState","text":"<pre><code>classDiagram\n    class IState{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IState.cs</code> is used by PersistentGameManager to create custom states for a StateMachine.</p>"},{"location":"systems/utilities/#eventlink","title":"EventLink","text":"<pre><code>classDiagram\n    class EventLink{\n    }</code></pre> <p>EventLinks are used to connect nodes in a StateMachine.</p> <p><code>EventLink.cs</code> is used by PersistentGameManager to link the paused and running game states.</p>"},{"location":"systems/utilities/#states","title":"States","text":"<pre><code>classDiagram\n    AbstractState &lt;|-- GameState\n    GameState &lt;|-- TemplateGameState\n    class AbstractState{\n    &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <p>AbstractStates represent the conceptual nodes of a StateMachine while GameStates represent actual game state nodes.</p> <p><code>AbstractState.cs</code> defines what is common across all AbstractStates, regardless of game.</p> <p><code>GameState.cs</code> defines what is common across all GameStates, regardless of game.</p> <p><code>TemplateGameState.cs</code> represents the GameStates in the template.</p>"},{"location":"systems/utilities/#interfaces","title":"Interfaces","text":"<p>These scripts contain collections of method signatures and properties that can be implemented by other scripts. All classes in these folder use the <code>interface</code> keyword in their declaration.</p> <p>Interfaces act like a contract; when a class implements an interface, an instance of that class can also be treated as an instance of that interface. This functionality means that two unrelated classes can be treated in the same way through an interface that they both implement.</p>"},{"location":"systems/utilities/#icanface","title":"ICanFace","text":"<pre><code>classDiagram\n    class ICanFace{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>ICanFace.cs</code> is implemented by classes that can face a specific Direction. It is implemented by VillainController so that BasicEnemyAI can control the direction the unit faces.</p>"},{"location":"systems/utilities/#icanmove","title":"ICanMove","text":"<pre><code>classDiagram\n    class ICanMove{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>ICanMove.cs</code> is implemented by classes that can move conditionally. It is implemented by UnitController so that BeltScrollMove can know if the unit can currently move.</p>"},{"location":"systems/utilities/#icanstop","title":"ICanStop","text":"<pre><code>classDiagram\n    class ICanStop{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>ICanStop.cs</code> is implemented by classes that can stop. It is implemented by BeltScrollMove so that UnitController can stop the unit from moving when needed.</p>"},{"location":"systems/utilities/#idamageable","title":"IDamageable","text":"<pre><code>classDiagram\n    class IDamageable{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IDamageable.cs</code> is implemented by classes that are damageable. It is implemented by UnitController to notify StateMachineBehaviours that the unit was damaged so that the animation state machine can update accordingly.</p>"},{"location":"systems/utilities/#idefeatable","title":"IDefeatable","text":"<pre><code>classDiagram\n    class IDefeatable{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IDefeatable.cs</code> is implemented by classes that are defeatable. It is implemented by UnitController to notify StateMachineBehaviours that the unit was defeated so that the animation state machine can update accordingly.</p>"},{"location":"systems/utilities/#ihavedamage","title":"IHaveDamage","text":"<pre><code>classDiagram\n    class IHaveDamage{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveDamage.cs</code> is implemented by classes that have damage. It is implemented by JabAbilityData and CrossAbilityData so that a target's HurtResponder knows that it has to process damage as part of its hurt response.</p>"},{"location":"systems/utilities/#ihavedirection","title":"IHaveDirection","text":"<pre><code>classDiagram\n    class IHaveDirection{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveDirection.cs</code> is implemented by classes that have Direction. It is implemented by UnitController so that JabHitbox and CrossHitbox know what direction to perform their boxcasts when getting hit info from a collision.</p>"},{"location":"systems/utilities/#ihavefloatinghealthbar","title":"IHaveFloatingHealthBar","text":"<pre><code>classDiagram\n    class IHaveFloatingHealthBar{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveFloatingHealthBar.cs</code> is implemented by classes that have a floating health bar transform. It is implemented by VillainController so that FloatingHealthBarController knows where to position the unit's floating health bar.</p>"},{"location":"systems/utilities/#ihavehitstun","title":"IHaveHitStun","text":"<pre><code>classDiagram\n    class IHaveHitStun{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveHitStun.cs</code> is implemented by classes that have hitstun. It is implemented by JabAbilityData and CrossAbilityData so that a target's HurtResponder knows that it has to process hitstun as part of its hurt response.</p>"},{"location":"systems/utilities/#ihavehurtboxes","title":"IHaveHurtboxes","text":"<pre><code>classDiagram\n    class IHaveHurtboxes{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveHurtboxes.cs</code> is implemented by classes that have hurtboxes. It is implemented by HeroController so that BasicEnemyAI can calculate the closest possible target hurtbox.</p>"},{"location":"systems/utilities/#ihavehurtboxmask","title":"IHaveHurtboxMask","text":"<pre><code>classDiagram\n    class IHaveHurtboxMask{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveHurtboxMask.cs</code> is implemented by classes that have a hurtbox mask. It is implemented by UnitController so that JabHitbox and CrossHitbox know what type of hurtbox they collide with when active.</p>"},{"location":"systems/utilities/#ihaveknockback","title":"IHaveKnockback","text":"<pre><code>classDiagram\n    class IHaveKnockback{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveKnockback.cs</code> is implemented by classes that have knockback. It is implemented by JabAbilityData and CrossAbilityData for two reasons:</p> <ol> <li>So that JabHitbox and CrossHitbox can assign knockback direction after a collision based on hit info.</li> <li>So that a target's HurtResponder knows that it has to process knockback as part of its hurt response.</li> </ol>"},{"location":"systems/utilities/#ihavemaximumhealth","title":"IHaveMaximumHealth","text":"<pre><code>classDiagram\n    IHaveMaximumHealth &lt;|-- IHealth\n    class IHaveMaximumHealth{\n    &lt;&lt;Interface&gt;&gt;\n    }\n    class IHealth{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveMaximumHealth.cs</code> is implemented by classes that have maximum health. It is implemented by UnitStats so that a UnitController can initialize its HealthBehaviour with the correct maximum health.</p>"},{"location":"systems/utilities/#ihealth","title":"IHealth","text":"<p><code>IHealth.cs</code> is implemented by classes that have health. It is implemented by UnitController for two reasons:</p> <ol> <li>So that GameplayScreenController can initialize the Hero's health bar with the correct current and maximum health.</li> <li>So that FloatingHealthBarManager can initialize the Villain's floating health bar with the correct current and maximum health.</li> </ol>"},{"location":"systems/utilities/#ihavename","title":"IHaveName","text":"<pre><code>classDiagram\n    class IHaveName{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveName.cs</code> is implemented by classes that have a name. It is implemented by UnitController so that UnitActionManager can out output debug logs when attempting to perform UnitActions.</p>"},{"location":"systems/utilities/#ihaverange","title":"IHaveRange","text":"<pre><code>classDiagram\n    class IHaveRange{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveRange.cs</code> is implemented by classes that have range. It is implemented by JabUnitAction and CrossUnitAction so that BasicEnemyAI knows the maximum range at which to position itself in order to hit with the edge of an ability.</p>"},{"location":"systems/utilities/#ihavewalkspeed","title":"IHaveWalkSpeed","text":"<pre><code>classDiagram\n    class IHaveWalkSpeed{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IHaveWalkSpeed.cs</code> is implemented by classes that have walk speed. It is implemented by UnitStats and UnitController for two reasons:</p> <ol> <li>So that TrainingAIPlayerUnitManager can randomize Villain walk speeds within a set range of their base walk speed.</li> <li>So that each instance of BeltScrollMove can set its internal walk speed via BeltScrollMoveUnitAction.</li> </ol>"},{"location":"systems/utilities/#ipausable","title":"IPausable","text":"<pre><code>classDiagram\n    class IPausable{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IPausable.cs</code> is implemented by classes that are pausable. It is implemented by BeltScrollMove to allow a UnitController to pause and unpause its behavior.</p>"},{"location":"systems/utilities/#ipauseanimator","title":"IPauseAnimator","text":"<pre><code>classDiagram\n    class IPauseAnimator{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IPauseAnimator.cs</code> is implemented by classes that can pause the animator. It is implemented by UnitController to notify StateMachineBehaviours that the unit was paused so that the animation state machine can update accordingly.</p>"},{"location":"systems/utilities/#iraisemoveexecuted","title":"IRaiseMoveExecuted","text":"<pre><code>classDiagram\n    class IRaiseMoveExecuted{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IRaiseMoveExecuted.cs</code> is implemented by classes that raise a move executed event. It is implemented by BeltScrollMove for two reasons:</p> <ol> <li>So that HeroController can have the unit face the direction it is moving.</li> <li>To notify StateMachineBehaviours that the unit is moving so that the animation state machine can update accordingly.</li> </ol>"},{"location":"systems/utilities/#iraisesetanimationbool","title":"IRaiseSetAnimationBool","text":"<pre><code>classDiagram\n    class IRaiseSetAnimationBool{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IRaiseSetAnimationBool.cs</code> is implemented by classes that set an animation bool. It is implemented by Jab and Cross to notify StateMachineBehaviours that the user is executing an ability so that the animation state machine can update accordingly.</p>"},{"location":"systems/utilities/#iraisewon","title":"IRaiseWon","text":"<pre><code>classDiagram\n    class IRaiseWon{\n    &lt;&lt;Interface&gt;&gt;\n    }</code></pre> <p><code>IRaiseWon.cs</code> is implemented by classes that raise a win. It is implemented by UnitController to notify StateMachineBehaviours that the unit has won so that the animation state machine can update accordingly.</p>"},{"location":"systems/utilities/#monobehaviours","title":"MonoBehaviours","text":"<p>These scripts are meant to be attached to GameObjects in the scene as components and inherit from Unity's MonoBehaviour class.</p>"},{"location":"systems/utilities/#horizontaldolly","title":"HorizontalDolly","text":"<pre><code>classDiagram\n    class HorizontalDolly{\n    }</code></pre> <p><code>HorizontalDolly.cs</code> is used to have the x-position of a GameObject follow the x-position of a human player unit. This component can be found attached to the MainCamera GameObject in the Training scene.</p>"},{"location":"systems/utilities/#lerp","title":"Lerp","text":"<pre><code>classDiagram\n    class Lerp{\n    }</code></pre> <p><code>Lerp.cs</code> is used to animate a GameObject's movement between two points. This component can be found attached to the Clouds GameObject in the Title scene.</p>"},{"location":"systems/utilities/#loadsceneonstart","title":"LoadSceneOnStart","text":"<pre><code>classDiagram\n    class LoadSceneOnStart{\n    }</code></pre> <p><code>LoadSceneOnStart.cs</code> is used to immediately load a new scene. This component can be found attached to the Initializer GameObject in the Initialization scene and the SceneLoader GameObject in the Persistent scene.</p>"},{"location":"systems/utilities/#matchscalexsignwithtransform","title":"MatchScaleXSignWithTransform","text":"<p><pre><code>classDiagram\n    class MatchScaleXSignWithTransform{\n    }</code></pre> <code>MatchScaleXSignWithTransform.cs</code> is used to have a GameObject's scale x sign always copy that of another GameObject's scale x sign. This component can be found attached to the UI GameObject of Human prefab and its Hero and Villain prefab variants. These prefabs are instantiated as children of the HumanPlayerUnitManager and AIPlayerUnitManager GameObjects in the Training scene at runtime.</p>"},{"location":"systems/utilities/#propertyattributes","title":"PropertyAttributes","text":"<p>These scripts contain custom attributes for script variables. All classes in this folder derive from Unity's base <code>PropertyAttribute</code> class.</p>"},{"location":"systems/utilities/#readonlyattribute","title":"ReadOnlyAttribute","text":"<pre><code>classDiagram\n    class ReadOnlyAttribute{\n    }</code></pre> <p><code>ReadOnlyAttribute.cs</code> is used to denote fields that are read-only in the Unity Editor Inspector window.</p>"},{"location":"systems/utilities/#renameattribute","title":"RenameAttribute","text":"<pre><code>classDiagram\n    class RenameAttribute{\n    }</code></pre> <p><code>RenameAttribute.cs</code>  is used to change a field's name in the Unity Editor Inspector window.</p>"},{"location":"systems/utilities/#propertydrawers","title":"PropertyDrawers","text":"<p>These scripts contain custom drawers to control how script variables with custom PropertyAttributes appear in the Inspector. All classes in this folder derive from Unity's base <code>PropertyDrawer</code> class.</p>"},{"location":"systems/utilities/#readonlypropertydrawer","title":"ReadOnlyPropertyDrawer","text":"<pre><code>classDiagram\n    class ReadOnlyPropertyDrawer{\n    }</code></pre> <p><code>ReadOnlyPropertyDrawer.cs</code> controls how the serializable ReadOnlyAttribute class looks in the inspector.</p>"},{"location":"systems/utilities/#renamepropertydrawers","title":"RenamePropertyDrawers","text":"<pre><code>classDiagram\n    class RenamePropertyDrawers{\n    }cls</code></pre> <p><code>RenamePropertyDrawer.cs</code> controls how the serializable RenameAttribute class looks in the inspector.</p>"}]}